<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot2.x+Spring Data Jpa整合简书]]></title>
    <url>%2F2018%2F06%2F11%2FSpringBoot2-x-Spring-Data-Jpa%E6%95%B4%E5%90%88%E7%AE%80%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[SpringDataJpa由Spring基于Hibernate开发的一个JPA框架。可以极大的简化JPA的写法，可以在几乎不用写实现的情况下，实现对数据的访问和操作。与SpringBoot整合更是锦上添花,下面我将讲解其用法。 1. 实体类123456789101112131415161718192021222324252627282930313233343536@Entity@Table(name = &quot;t_accountinfo&quot;)public class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; @NotNull(message = &quot;用户名不能为空&quot;) @Column(length = 64,nullable = false,unique = true) private String username; @NotNull(message = &quot;密码不能为空&quot;) private String password; private int age; @Lob private String image; @Email(message = &quot;邮箱格式错误&quot;) private String email; @Size(max=11,min=11,message=&quot;你所输入手机号不是１１位&quot;) private String phone; @CreationTimestamp private Timestamp createTime; @UpdateTimestamp private Timestamp updateTime; //此处 get() set()省略。。。&#125; 1. ＠Entity:代表这是一个实体Bean;@Table():其中的name属性代表的是所映射数据库表的名字,如果没有@Table，默认生成类名对应的表。如：User（类）-&gt;user(表); HuUser（类）-&gt;hu_user(表)2. ＠Id:代表这是一个主键；3. @GeneratedValue()增长策略：strategy属性其中有四个用法: TABLE：使用一个特定的数据库表格来保存主键。 SEQUENCE：根据底层数据库的序列来生成主键，条件是数据库支持序列。 IDENTITY：主键由数据库自动生成（主要是自动增长型） AUTO：主键由程序控制。 如果你想字符串生成uuid可自定义生成策略：@GenericGenerator(name = “uuid”,strategy = “uuid”)@GeneratedValue(generator = “uuid”) 4.@Column()代表字段映射的一些属性 lenth:表示该字段的长度，默认为２５５ nullable:表示该字段是否为空，默认为ture;注解使用@NotNull: message：为空时抛出的错误信息 unqique:表示该字段是否唯一；默认为false; 其他的没用过！！！ 5. 字段约束 ＠Size表示字段一些约束：mix：最小长度；max：最大长度，message:表示违反约束抛出的错误信息 ＠Enail:表示该字段格式必须为邮箱格式，其中message表示不满足时抛出的错误信息 @Pattern：regexp属性:正则表达式，message属性:不满足时抛出的错误信息 6. ＠Lob:该字段映射表中该字段类型为text属性7. @CreationTimestamp：表示插入数据自动生成时间; @UpdateTimestamp:更新数据时生成当前时间;8. @OneToMany一对多，@ManyToOne多对一 mappedBy:用于双向关联时使用，值为放弃维护的表名，否则会引起数据不一致的问题 fetch:可取的值有FetchType.EAGER:即时加载；FetchType.LAZY：懒加载;@OneToMany中默认为懒加载 cascade：CascadeType.PERSIST（级联新建）、CascadeType.REMOVE（级联删除）、CascadeType.REFRESH（级联刷新）、CascadeType.MERGE（级联更新）、CascadeType.ALL（选择全部） ９. @ManyToOne多对一 optional 属性是定义该关联类对是否必须存在，值为false时，关联类双方都必须存在，如果关系被维护端不存在，查询的结果为null。 值为true 时, 关系被维护端可以不存在，查询的结果仍然会返回关系维护端，在关系维护端中指向关系被维护端的属性为null。 optional 属性的默认值是true。 其他和 @OneToMany一样，注意：fetch默认为即时加载 9. @ManyToMany多对多 fetch默认为懒加载 定义多对多时的其他配置：实例 12345//name:第三张表的表名；joinColumns和inverseJoinColumns：:name:字段名;referencedColumnName:绑定哪个字段名，nullable：是否可以为空； @JoinTable(name = &quot;user_role&quot;, joinColumns = @JoinColumn(name = &quot;user_id&quot;,referencedColumnName = &quot;Id&quot;,nullable = false), inverseJoinColumns =@JoinColumn(name = &quot;role_id&quot;,referencedColumnName = &quot;id&quot;,nullable = false)) 10. 其他 @NotNull:不能为空 message：为空时抛出的错误信息 ２. 接口这里我就讲解我所用的： 1extends JpaRepository&lt;User,Long&gt; 定义一个接口继承此接口 &lt;User,Long&gt;第一个值为映射表中的类名，第二个值为此类的Id类型 默认的方法: save:新增或修改一条数据;saveAll：新增或修改多条数据； 注意：当传入的数据没有id时，会是修改数据 delete:删除一条数据；deleteById:根据id删除数据； findById:根据id查询信息，返回的是Optional&lt;&gt;类型; finAll：查询所有信息；返回类型一个是List，一个是Page：分页的类型 还有其他的方法暂时没研究； 当然这些往往不够，还有一些自定义的方法: 关键字—————–样例——————————–对应sql And——————findByUsername——————…where username=?1 Or——————-findByUsernameOrAge————-…where username=?! or age=?2 Like—————–findByUsernameLike————-…where username like ?1 Between————–findByAgeBetween—————…where age between 1? and ?2 LessThan————–findByAgeLessThan————-…where age&lt;?1 LessThanEqual————-findByAgeLessThanEqual————-…where age&lt;=?1 GreaterThan—————findByAgeGreaterThan—————…where age&gt;?1 GreaterThanEqual————-findByAgeGreaterThanEqual————-…where age&gt;=?1 findDistinct：去重; 其他：还有其他关键字我就不写了，可以去查； 3. @Query如果上面那些还不能达到你的要求，那就是用@Query 属性:nativeQuery = true时 代表可以写原生的sql语句了。。对，没错原生的，不是hql语句；例子： 12@Query(value = &quot;SELECT c.id,c.name,c.create_time,c.update_time,c.comment FROM aimi_store.user_role AS a JOIN aimi_store.aimi_user AS b ON a.user_id=b.id JOIN aimi_store.`role` AS c ON a.role_id=c.id WHERE b.id=?1&quot;,nativeQuery = true)List&lt;Role&gt; listRoleByUser(String Id); 没错，任何sql语句都可以写，所以，，可以和mybatis一较高下来了;还有其他很多功能我就不一一说出来了，你们可以看文档； 1. 总结Spring Data Jpa 是真的太强大了，不仅有默认的基本方法，分页简单；还可以写原生sql语句。和SpringBoot整合，简直完美！！！]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringDataJpa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础回顾篇以及面试要点！]]></title>
    <url>%2F2018%2F06%2F07%2FJava%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%E7%AF%87%E4%BB%A5%E5%8F%8A%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%EF%BC%81%2F</url>
    <content type="text"><![CDATA[Java基础很重要，他会让你在写项目的时候避免坑以及提高代码质量等等，本人忽视了这点，所以这次特也写篇博客牢固Java知识要点，好了，话不多说，开始吧！ 1. Java编译和运行过程 源文件由编译器编译成字节码文件（ByteCode） 字节码有Java虚拟机解释运行 2. Java面向对象四个基本特性 抽象:把具有相同属性和行为的对象被抽象成类 封装：把对象封装成高度自治和相对封闭的个体，对象属性由自己读取和改变 继承：把已经存在的类已定义的内容作为自己的，并可加入新内容或修改原来的方法 多态：不同类的对象对同一消息做出不同反应 3. Java中对象的生命周期 创建阶段–&gt;应用阶段–&gt;不可见阶段–&gt;不可达阶段–&gt;收集阶段–&gt;终结阶段–&gt;对象空间重新分配阶段 4. Java 8种数据类型 byte：1个字节 short2个字节 int：4个字节 long：8个字节 float：4个字节 duble：8个字节 boolean：2个字节 char ：1位 5. ==与equals区别 ==：比较两个对象的地址 equals：比较两个对象内容 6. String，StringBuffer，StringBuilder区别 String：内容不可变，底层使用的是不可变的字符数组（private final char value[]） StringBuffer:内容可变，底层使用的是可变字符数组（char [] vale），线程安全 StringBuilder:内容可变，底层使用的是可变字符数组（char [] vale），线程不安全，效率相对于StringBuffer高些。 7. ArrayList与LinkedList区别 ArrayList：底层使用的是数组实现，查询用ArrayList，因为LinkedList需要移动指针 LinkedList：底层使用的是链表，更新删除用LinkedList，因为ArrayList需要移动数据 8. HashMap和HashTable的区别 相同点:都是Key-value的数据 HashMap：key和value可以为null，线程不安全，效率高 hashtable：Key和value不可为null，线程安全，效率低 想线程安全，效率高使用ConcurrentHashMap：把整个Map分成N个Segment（类似HashTable） 9. 借口(interface)和抽象类(abstract class) 抽象类中可有抽象方法和具体方法，接口中的方法都是抽象方法（注意：JDK1.8后接口添加了一种默认方法-default和静态方法。） 静态方法：默认方法允许接口方法定义默认实现，而所有子类都将拥有该方法及实现。 静态方法：由于它是静态的，所以由接口定义的静态方法可以独立于任何对象被调用。因此，调用静态方法不需要实现接口。 12345678public interface TestInter &#123; default String getDefault()&#123; return &quot;default&quot;; &#125; static String getStatic()&#123; return &quot;static&quot;; &#125;&#125; 类可以实现（implements）多个接口但只能继承（extends）一个抽象类 接口中的成员都是public ；抽象类的成员可以是private，protected，public（注意：JDK1.9之后：接口支持私有化） 10. 字符流和字节流 字符流处理的基本单位是字符（Java中的字符是16位的），输入流以Reader为基础，输出流以Writer为基础，常用读取字符数据； 字节流的基本单位是字节（Java中的字节是8位的），输入流以 InputStream为基础，输出流以 OutputStream为基础，常用读取二进制文件也就是对文件的操作； 11. Java线程 Java多线程的实现：继承Thread类重写run函数，实现Runnable接口 线程池作用：不需要每次去创建和销毁线程了，节约资源和相应时间更快 12. Sleep和wait Sleep()：是线程Thread类的静态方法，调用此方法会让当前线程暂停到指定时间，将执行机会给其他线程，但对象锁依然保持，结束后自动回复 wait():调用此方法会导致当前线程放弃对象锁 13. 线程与进程的区别 进程是资源的分配和调度的一个独立单元，线程是CPU调度的基本单位 同一进程中可以包含多个线程，并且线程共享整个进程资源 14. Java设计模式（举例几个） 单例模式：①构造方法私有化，让除了自己类中能创建外其他地方都不能创建②在自己类中创建单实例③提供一个方法获取该实例对象 12345678910111213public class Single&#123; private static Single single=null; //声明静态的单例对象的变量 private Singleton()&#123;&#125; //私有构造方法 //外部通过此方法可以获取对象 public synchronized static Singlet getSingle()&#123; if(single == null)&#123; single=new Single() &#125; return single; &#125; &#125; 工厂模式：对象的创建交给工厂来创建,SpringIOC就是工厂模式？ 代理模式：Spring的AOP就是使用了动态代理。 15. MVC开发模式 M model模型层 应用程序中用于处理数据逻辑的部分 V view 视图层 应用程序中用于数据展示的部分 C controller 控制层应用程序中用于处理用户请求的部分\ 16. Spring IOC(控制反转)理解: 对组件的对象进行控制权转移，从程序代码本身转移到外部容器，由容器来创建对象并管理对象之间的依赖关系；实现: 通过反射创建实例 AOP(面向切面编程)理解: 将程序中的交叉业务逻辑（安全，日志，事物），封装成一个切面，然后注入到目标对象（具体业务逻辑）中去，完善依赖注入;实现: 动态代理，JDK动态代理 17. SpringMVC 原理 (1):客户端的所有请求都交给前端控制器DispatcherServlet来处理， (2):DispatcherServlet收到请求后，将根据请求信息（URL，请求头，参数，等）以及HanderMapping的配置找到处理该请求的Controller (3):Conroller调用业务逻辑处理后，返回ModelAndView (4):DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。 (5):视图负责将结果显示到客户端##总结由于本人太过疏忽Java基础，些项目也遇到过很多坑，对于即将毕业的我面试过几家，都因基础太差而被淘汰，深感懊悔，特此写下这些！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot2.x+SpringSecurit+JWT(三)前后端分离进阶]]></title>
    <url>%2F2018%2F06%2F05%2FSpringBoot2-x-SpringSecurit-JWT-%E4%B8%89-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[此次文章是上一篇文章进阶片，以Token的方式进行验证，Token的生成策略是JWT，如有不懂请看上一篇文章SpringBoot2.x+SpringSecurit(二)前后端分离 什么是JWT,为什么使用JWT? JWT是 Json Web Token 的缩写。它是基于 RFC 7519 标准定义的一种可以安全传输的小巧和 自包含的JSON对象。由于数据是使用数字签名的，所以是可信任的和安全的。JWT可以使用HMAC算法对secret进行加密或者使用RSA的公钥私钥对来进行签名。 使用 JWT 做权限验证，相比Session的优点是，Session 需要占用大量服务器内存，并且在多服务器时就会涉及到共享Session问题，而JWT无需存储在服务器,不占用服务器资源（也就是无状态的），用户在登录后拿到 Token 后，访问需要权限的请求时附上Token（一般设置在Http请求头）。 工作流程 输入用户名、密码，进行登录 服务器验证登录鉴权，如果用户合法，根据用户的信息生成JWT Token 服务器将该token以json形式返回（不一定要json形式） 前端得到token，储存起来 以后用户请求API时，在请求的header中加入 Authorization:Bearer xxxx(token)。此处 注意token之前有一个7长度字符的Bearer 。 服务器端对此token进行检验，如果合法就解析其中内容，根据其拥有的权限和自己的业务逻辑给出对应的响应结果。 1. 引入依赖12//jwtcompile &apos;io.jsonwebtoken:jjwt:0.9.0&apos; 2. Security 配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled=true)public class WebSecurityConfig extends WebSecurityConfigurerAdapter&#123; @Autowired private UserDetailsService userDetailsService; @Autowired private AuthSuccessHandler authSuccessHandler; @Autowired private AuthFailHandler authFailHandler; @Autowired private AuthAccessDeniedHandler authAccessDeniedHandler; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder()); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; ExpressionUrlAuthorizationConfigurer&lt;HttpSecurity&gt;.ExpressionInterceptUrlRegistry registry=http.authorizeRequests(); for (String u:PermitUrl.permitUrls) &#123; registry.antMatchers(u).permitAll(); &#125; registry.and() .formLogin() .loginPage(&quot;/u/noLogin&quot;) .loginProcessingUrl(&quot;/login&quot;) .permitAll() //成功处理类 .successHandler(authSuccessHandler) //失败处理类 .failureHandler(authFailHandler) .and() .logout() .permitAll() .and() .authorizeRequests() //任何请求 .anyRequest() //都需要认证 .authenticated() .and() //关闭跨站请求防护 .csrf().disable() //前后端分离采用JWT 不需要session .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) .and() //自定义权限拒绝处理类 .exceptionHandling().accessDeniedHandler(authAccessDeniedHandler) .and() //添加JWT过滤器 除/login其它请求都需经过此过滤器 .addFilter(new JwtAuthenticationFilter(authenticationManager())); &#125;&#125; 这里不需要session储存了，以及重现验证机制 3. 成功配置文件12345678910111213141516171819202122232425262728@Slf4j@Componentpublic class AuthSuccessHandler implements AuthenticationSuccessHandler &#123; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; //获取登陆成功用户名 String username = ((UserDetails)authentication.getPrincipal()).getUsername(); log.info(&quot;登陆成功:&#123;&#125;&quot;,username); List&lt;String&gt; authorities=((UserDetails) authentication.getPrincipal()).getAuthorities().stream().map(a-&gt;new String(((GrantedAuthority) a).getAuthority())).collect(Collectors.toList()); //登陆成功生成JWT String token = Jwts.builder() //主题 放入用户名 .setSubject(username) //自定义属性 放入用户拥有权限 .claim(SecurityConstant.AUTHORITIES.getCode(), JSONObject.toJSONString(authorities)) //失效时间 7天 .setExpiration(new Date(System.currentTimeMillis() + 60 * 60 * 24 *7)) //签名算法和密钥 .signWith(SignatureAlgorithm.HS512,SecurityConstant.JWT_SIGN_KEY.getCode()) .compact(); token = SecurityConstant.TOKEN_SPLIT.getCode() + token; String msg=JSON.toJSONString(ServerResponse.Success(token)); ServerResponse.out(response,msg); &#125;&#125; 登陆成功后获取用户信息，以及权限，以JWT的HS512算法生成Token 然后以json返回给前端。注意:如果你是JDK1.8以上需要加入compile &#39;javax.xml.bind:jaxb-api:2.3.0&#39;依赖 4. 失败配置文件12345678910111213141516171819@Component@Slf4jpublic class AuthFailHandler implements AuthenticationFailureHandler &#123; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; String msg=null; if (exception instanceof UsernameNotFoundException || exception instanceof BadCredentialsException) &#123; msg=&quot;用户名或密码输入错误，登录失败!&quot;; &#125; else if (exception instanceof DisabledException) &#123; msg=&quot;账户被禁用，登录失败，请联系管理员!&quot;; &#125; else &#123; msg=&quot;登录失败！&quot;; &#125; msg=JSON.toJSONString(ServerResponse.Error(ResponseCode.INTERNAL_SERVER_ERROR.getCode(),msg)); ServerResponse.out(response,msg); &#125;&#125; 5. token校验类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@Slf4jpublic class JwtAuthenticationFilter extends BasicAuthenticationFilter &#123; public JwtAuthenticationFilter(AuthenticationManager authenticationManager) &#123; super(authenticationManager); &#125; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; String header = request.getHeader(SecurityConstant.HEADER.getCode()); if (header == null || !header.startsWith(SecurityConstant.TOKEN_SPLIT.getCode())) &#123; chain.doFilter(request, response); return; &#125; UsernamePasswordAuthenticationToken authentication = getAuthentication(request, response); SecurityContextHolder.getContext().setAuthentication(authentication); chain.doFilter(request, response); &#125; private UsernamePasswordAuthenticationToken getAuthentication(HttpServletRequest request, HttpServletResponse response) &#123; String token = request.getHeader(SecurityConstant.HEADER.getCode()); if (token!=null)&#123; Claims claims = null; try &#123; claims=Jwts.parser() .setSigningKey(SecurityConstant.JWT_SIGN_KEY.getCode()) .parseClaimsJws(token.replace(SecurityConstant.TOKEN_SPLIT.getCode(), &quot;&quot;)) .getBody(); //获取用户名 String username = claims.getSubject(); //获取权限（角色） List&lt;GrantedAuthority&gt; authorities=null; String authority = claims.get(SecurityConstant.AUTHORITIES.getCode()).toString(); if(authority!=null)&#123; List&lt;String&gt; list = JSONObject.parseArray(authority,String.class); authorities= list.stream().map(a-&gt;new SimpleGrantedAuthority(a)).collect(Collectors.toList()); &#125; if(username!=null) &#123; //此处password不能为null User user=new User(username,&quot;&quot;,authorities); return new UsernamePasswordAuthenticationToken(user, null, authorities); &#125; &#125;catch (ExpiredJwtException e) &#123; logger.error(&quot;Token已过期: &#123;&#125; &quot; + e); String msg=JSON.toJSONString(ServerResponse.Error(ResponseCode.INTERNAL_SERVER_ERROR.getCode(),&quot;Token已过期&quot;)); ServerResponse.out(response,msg); &#125; catch (UnsupportedJwtException e) &#123; logger.error(&quot;Token格式错误: &#123;&#125; &quot; + e); String msg=JSON.toJSONString(ServerResponse.Error(ResponseCode.INTERNAL_SERVER_ERROR.getCode(),&quot;Token格式错误&quot;)); ServerResponse.out(response,msg); &#125; catch (MalformedJwtException e) &#123; logger.error(&quot;Token没有被正确构造: &#123;&#125; &quot; + e); String msg=JSON.toJSONString(ServerResponse.Error(ResponseCode.INTERNAL_SERVER_ERROR.getCode(),&quot;Token没有被正确构造&quot;)); ServerResponse.out(response,msg); &#125; catch (SignatureException e) &#123; logger.error(&quot;签名失败: &#123;&#125; &quot; + e); String msg=JSON.toJSONString(ServerResponse.Error(ResponseCode.INTERNAL_SERVER_ERROR.getCode(),&quot;签名失败&quot;)); ServerResponse.out(response,msg); &#125; catch (IllegalArgumentException e) &#123; logger.error(&quot;非法参数异常: &#123;&#125; &quot; + e); String msg=JSON.toJSONString(ServerResponse.Error(ResponseCode.INTERNAL_SERVER_ERROR.getCode(),&quot;非法参数异常&quot;)); ServerResponse.out(response,msg); &#125; &#125; return null; &#125;&#125; 这里判断请求的header格式是否正确，如正确，解析Token获取用户信息 6. 测试如果访问其他API这里的值为你登录的Bearer +Token。 7. 总结 源码请看：源码这里以JWT生成Token和储存Token，那么如何以redis储存呢？]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot2.x+SpringSecurit(二)前后端分离]]></title>
    <url>%2F2018%2F05%2F15%2FSpringBoot2-x-SpringSecurit-%E4%BA%8C-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[遇到前后端分离时SpringSecurity权限的处理和之前的也有点差异，本文讲述Spring Boot2.x整合Spring Security前后端分离，对上一篇的配置进行修改，如果不懂的先看上一篇文章SpringBoot2.x+SpringSecurity(一)安全配置整合 1. Spring Securit配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Configuration@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled=true)public class WebSecurityConfig extends WebSecurityConfigurerAdapter&#123; @Autowired private UserDetailsService userDetailsService; @Autowired private AuthSuccessHandler authSuccessHandler; @Autowired private AuthFailHandler authFailHandler; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(userDetailsService).passwordEncoder(new BCryptPasswordEncoder()); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; ExpressionUrlAuthorizationConfigurer&lt;HttpSecurity&gt;.ExpressionInterceptUrlRegistry registry=http.authorizeRequests(); registry.and() .formLogin() .loginPage(&quot;/u/noLogin&quot;) .loginProcessingUrl(&quot;/login&quot;) .permitAll() //成功处理类 .successHandler(authSuccessHandler) //失败处理类 .failureHandler(authFailHandler) .and() .logout() .permitAll() .and() .authorizeRequests() //任何请求 .anyRequest() //都需要认证 .authenticated() .and() //关闭跨站请求防护 .csrf().disable() .and() //自定义权限拒绝处理类 .exceptionHandling().accessDeniedHandler(authAccessDeniedHandler) &#125;&#125; 这里的successHandler(）以及failureHandler()就是当验证成功时以及失败时调用自己写的方法，.exceptionHandling().accessDeniedHandler(）依然也是一样的，因为我我们不用默认的了； 2. 成功处理类1234567891011121314@Slf4j@Componentpublic class AuthSuccessHandler implements AuthenticationSuccessHandler &#123; @Override public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123; log.info(&quot;登陆成功&quot;); String msg=JSON.toJSONString(ServerResponse.Success(authentication.getPrincipal())); ServerResponse.out(response,msg); &#125;&#125; 当登录验证成功时由AuthenicationSuccessHandler策略接口控制，实现onAuthenticationSuccess方法，authentication.getPrincipal()是当前登录成功时的用户信息，以json返回给前端。 3. 失败处理类123456789101112131415161718@Component@Slf4jpublic class AuthFailHandler implements AuthenticationFailureHandler &#123; @Override public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123; String msg=null; if (exception instanceof UsernameNotFoundException || exception instanceof BadCredentialsException) &#123; msg=&quot;用户名或密码输入错误，登录失败!&quot;; &#125; else if (exception instanceof DisabledException) &#123; msg=&quot;账户被禁用，登录失败，请联系管理员!&quot;; &#125; else &#123; msg=&quot;登录失败！&quot;; &#125; msg=JSON.toJSONString(ServerResponse.Error(ResponseCode.INTERNAL_SERVER_ERROR.getCode(),msg)); ServerResponse.out(response,msg); &#125;&#125; 当验证失败时由AuthenticationFailureHandlerc策略借口控制，实现 onAuthenticationFailure方法返回错误信息 4. 权限拒绝处理类12345678910@Slf4j@Componentpublic class AuthAccessDeniedHandler implements AccessDeniedHandler &#123; @Override public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException &#123; log.error(&quot;权限不足！&quot;); response.sendError(HttpServletResponse.SC_UNAUTHORIZED, &quot;权限不足！&quot;); &#125;&#125; 5. 测试返回的结果：data里就是当前验证成功的信息，status是自定义返回状态； 6. 小结在此继续研究下去！]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot2.x+SpringSecurity(一)安全配置整合]]></title>
    <url>%2F2018%2F05%2F05%2FSpringBoot2.x-SpringSecurity-%E4%B8%80%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[首先我是一名大学生，最近了解到SpringSecurity,其功能非常强大，与SpringBoot完美整合，本文讲述Spring Boot2.x整合Spring Security在方法上使用注解实现权限控制，使用自定义UserDetailService，从MySQL中加载用户信息。使用Security推荐的BCrypt对用户的密码进行加密。页面模板采用thymeleaf引擎。 1. 引入依赖123456compile(&apos;org.springframework.boot:spring-boot-starter-data-jpa&apos;)compile(&apos;org.springframework.boot:spring-boot-starter-security&apos;)compile(&apos;org.springframework.boot:spring-boot-starter-thymeleaf&apos;)compile(&apos;org.springframework.boot:spring-boot-starter-web&apos;)runtime(&apos;mysql:mysql-connector-java&apos;)compile &apos;com.alibaba:druid-spring-boot-starter:1.1.9&apos; 这里使用druid连接池，Spring Data Jpa做数据访问 2. Spring Securit配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * @author 胡少 * 安全配置 */@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true)//开启Security注解public class SecurityConfig extends WebSecurityConfigurerAdapter &#123; private static final String KEY=&quot;https://github.com/HuShao96&quot;; @Autowired private UserDetailsService userDetailsService; @Autowired private PasswordEncoder passwordEncoder; /** * 自定义配置类 * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http)throws Exception&#123; http.authorizeRequests() //静态文件允许你访问 .antMatchers(&quot;/css/**&quot;,&quot;/js/**&quot;,&quot;/fonts/**&quot;).permitAll() //所有的请求需要认证即登陆后才能访问 .anyRequest().authenticated() .and() //form表单验证 .formLogin().loginPage(&quot;/login&quot;) //设置默认登陆成功跳转的页面 .defaultSuccessUrl(&quot;/index&quot;) //登陆失败的请求 .failureUrl(&quot;/login-error&quot;).permitAll() .and() //开启cookie保存用户数据 .rememberMe() //设置cookie有效期 .tokenValiditySeconds(60 * 60 * 24 * 7) //设置cookie私钥 .key(KEY) //处理异常，拒绝访问就重定向403页面 .and().exceptionHandling().accessDeniedPage(&quot;/403&quot;); &#125; /** * 认证信息 * @param auth * @throws Exception */ @Autowired public void configureGlobal(AuthenticationManagerBuilder auth)throws Exception&#123; auth.userDetailsService(userDetailsService) //使用BCrypt加密 .passwordEncoder(new BCryptPasswordEncoder()); &#125; 这里做的配置有： 设置了登录url、登录成功和失败跳转的url以及异常跳转的url。 开启cookie保存用户数据并设置有效期以及私钥，这样前台页面提供name=”remember-me”的checkbox就可实现。 使用@EnableGlobalMethodSecurity(prePostEnabled = true)这个注解，可以开启security的注解，我们可以在需要控制权限的方法上面使用@PreAuthorize，@PreFilter这些注解。 3. 自定义userDetailService123456789101112131415161718192021@Servicepublic class UserDetailsServiceImpl implements UserDetailsService &#123; @Autowired private UserRepository userRepository; @Autowired private RoleRepository roleRepository; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; AimiUser user=userRepository.findByUsername(username); if(user!=null)&#123; //获取权限，如果用户实体类实现了UserDetails接口的不需要此操作 List&lt;Role&gt; roles=roleRepository.listRoleByUser(user.getId()); return new SecurityUserDetails(user,roles); &#125; return null; &#125;&#125; 这里只需要实现UserDetailsService 接口，重写loadUserByUsername方法，从数据库中取出用户信息，并根据信息获取权限，最后返回一个UserDetails 实现类。 4. 定义UserDetails实体1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class SecurityUserDetails implements UserDetails &#123; private String username; private String password; private List&lt;Role&gt; roles; public SecurityUserDetails(AimiUser user, List&lt;Role&gt; roles) &#123; this.username = user.getUsername(); this.password = user.getPassword(); this.roles = roles; &#125; @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123; List&lt;GrantedAuthority&gt; authorities=new ArrayList&lt;&gt;(); List&lt;Role&gt; roles=this.roles; for(Role role:roles)&#123; authorities.add(new SimpleGrantedAuthority(role.getName())); &#125; return authorities; &#125; @Override public String getPassword() &#123; return password; &#125; @Override public String getUsername() &#123; return username; &#125; /** * 是否过期 * @return */ @Override public boolean isAccountNonExpired() &#123; return true; &#125; /** * 是否被锁定 * @return */ @Override public boolean isAccountNonLocked() &#123; return true; &#125; /** * 是否过期 * @return */ @Override public boolean isCredentialsNonExpired() &#123; return true; &#125; /** * 是否可用 * @return */ @Override public boolean isEnabled() &#123; return true; &#125;&#125; 5. 定义Controller控制器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Controllerpublic class TestController &#123; @GetMapping(&quot;/index&quot;) public String index() &#123; return &quot;index&quot;; &#125; @PreAuthorize(&quot;hasRole(&apos;admin&apos;)&quot;) @GetMapping(&quot;/admin&quot;) public String admin()&#123; return &quot;admin&quot;; &#125; @GetMapping(&quot;/login&quot;) public String login()&#123; return &quot;login&quot;; &#125; @GetMapping(&quot;/&quot;) public String root() &#123; return &quot;index&quot;; &#125; /** * 登陆失败 * @return */ @GetMapping(&quot;/login-error&quot;) public String loginError(Model model)&#123; model.addAttribute(&quot;loginError&quot;,true); model.addAttribute(&quot;errorMsg&quot;,&quot;登陆失败！&quot;); return &quot;login&quot;; &#125; @GetMapping(&quot;/403&quot;) public String error(Model model)&#123; model.addAttribute(&quot;error&quot;,&quot;权限不够&quot;); return &quot;403&quot;; &#125;&#125; 在admin()方法上面使用了@PreAuthorize(“hasRole(‘admin’)”)，表示访问这个方法需要拥有admin角色。如果想某指定某个角色能访问@PreAuthorize(“hasAnyRole(‘admin’,’user’)”)，更多的使用方法可以去看官方文档。 需要注意的是，Spring Security默认的角色前缀是”ROLE_”,使用hasRole方法时已经默认加上了，因此我们在数据库里面的用户角色应该是“ROLE_admin”，在admin前面加上”ROLE_”前缀 。 6. 前台登录页面1234567891011121314151617181920212223242526&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot; style=&quot; margin-top: 12%;&quot;&gt; &lt;div class=&quot;col-md-5 mx-auto&quot;&gt; &lt;form class=&quot;form-horizontal&quot; th:action=&quot;@&#123;/login&#125;&quot; method=&quot;post&quot;&gt; &lt;span class=&quot;heading&quot;&gt;登录&lt;/span&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;username&quot; id=&quot;username&quot; placeholder=&quot;用户名&quot;&gt; &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; name=&quot;password&quot; id=&quot;password&quot; placeholder=&quot;密 码&quot;&gt; &lt;i class=&quot;fa fa-lock&quot;&gt;&lt;/i&gt; &lt;a href=&quot;#&quot; class=&quot;fa fa-question-circle&quot;&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;div class=&quot;custom-control custom-checkbox&quot;&gt; &lt;input class=&quot;custom-control-input&quot; name=&quot;remember-me&quot; id=&quot;same-address&quot; type=&quot;checkbox&quot;&gt; &lt;label class=&quot;custom-control-label &quot; for=&quot;same-address&quot;&gt;记住我&lt;/label&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary float-right&quot;&gt;登录&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;text-danger text-center&quot; th:if=&quot;$&#123;loginError&#125;&quot; th:text=&quot;$&#123;errorMsg&#125;&quot; &gt;&lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 注意:这里的input里的name=username，name=password，name=remember-me 以及post登录方法:”/login”都是固定的如要更改，Security配置文件也需要配置 7. 附加如果访问除Get以外的方法可以会包403错误，原因是:框架内部防止CSRF（Cross-site request forgery跨站请求伪造）的发生，限制了除了get以外的大多数方法，解决办法如下： 首先在标签内添加如下内容12&lt;meta name=&quot;_csrf&quot; th:content=&quot;$&#123;_csrf.token&#125;&quot;/&gt; &lt;meta name=&quot;_csrf_hader&quot; th:content=&quot;$&#123;_csrf.headerName&#125;&quot;/&gt; ２. 然后在在ajax中添加代码如下： 123 var token = $(&apos;meta[name=&quot;_csrf&quot;]&apos;).attr(&quot;content&quot;); var header = $(&apos;meta[name=&quot;_csrf_hader&quot;]&apos;).attr(&quot;content&quot;);//接着在header请求头添加name=header,value=token; ８. 总结Spring Boot整合Spring Security大大简化了配置，使整个项目更安全！好了我要讲的到此为止！]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
</search>
